"""
파이썬의 리스트(List)는 말 그대로 순서대로 저장하는 시퀀스이자 변경 가능한 목록(Mutable List)를 말한다.
내부적으로는 동적 배열로 구현되어 있다. 리스트는 다양한 기능을 제공하면서 O(1)<-- 시간복잡도를 뜻함
에 실행 가능한 연산들도 몇 가지 있다. append로 추가하거나 pop으로 추출하거나 인데스로 요소를 조회하는 것은 O(1)
반면 요소를 삭제하거나 큐의 연산이기도 한 첫 번쨰 요소는 추출할때 pop(1)는 O(n)이다.. 전부다 꺼냈다가 다시 넣는 행동을 하는듯???

len(a) 전체 요소의 개수를 리턴  / 시간 복잡도 O(1)
a[i] 인덱스 i의 요소를 가져온다.  / O(1)
a[i:j] i부터 j까지 슬라이스의 길이만큼의 k개의 요소를 가져온다. 이 경우 k개에 대한 조회ㅏ가 필요하므로 O(k)이다.
elem in a elem 요소가 존재하는지 확인한다. 처음부터 순차 탐색하므로 n만큼의 시간이 소요된다. O(n)
a.count(elem)  elem 요소의 개수를 리턴한다. O(n)
a.index(elem)  elem 요소의 인덱스를 리턴한다. O(n) // <-- 헷갈릴 수 있는데 a.index(elem) 은 a리스트에 elem 값이 어딧는지 찾아주는 것이기때문에 최대 O(n)이다.
a.append(elem) 리스트 마지막에 elem 요소를 추가한다. O(1)
a.pop() 리스트 마지막 요소를 추출한다. 스택의 연산이다.  O(1)
a.pop(0) 리스트의 첫번쨰 요소를 추출한다. 큐의 연산이다. 이 경우 전체 복사가 필요하므로 O(n)이다.
큐의 연산을 주로 사용한다면 리스틑보다는 O(1)에 가능한 데크(deque)를 권장.
del a[i] i 에 따라 다르다. 최악의 경우 O(n)이다. <-- 이유는 i 값을 삭제하는데 순차적으로 접근하기때문에 마지막까지 하는경우가 최악인 경우 즉, O(n) 이다
a.sort() 정렬한다. 팀소트(Timsort)를 사용하여, 최선의 경우 O(n)에도 실행될 수 있다 O(n log n)
min(a), max(a) 최솟값/ 최댓값을 계산하기 위해서는 전체를 선형 탐색해야 한다. O(n)
a.reverse() 뒤집는다. 리스트는 입력 순서가 유지되므로 뒤집게 디ㅗ면 입력 순서가 반대로 된다. O(n)

"""

a = list()  # a = []
a = [1, 2, 3, 4]
a.insert(3, 5)  # 3번째 인덱스에 5를 넣는다. 3번째 인덱스에 있던 값은 뒤로 밀려난다.
a.append(True)
a.append("안녕")  # 리스트에는 자료형이 달라도 자유롭게 삽입할 수 있다.
print(a)

# a[9] 존재하지 않는 인덱스를 조회할 경우 다음과 같이 IndexError가 발생한다. 이런경우 try 구문으로 에러에 대한 예외처리를 할 수 있다.

try:
    print(a[9])

except IndexError:
    print("존재하지 않은 인덱스입니다.")


"""
아래와 같이 d = c 와 같이 하면 단순하게 d 가 c 를 참조하지만
e = c[:]와 같이하면 값의 사본을 복사한다.
"""
c = [1, 2, 3, 4]
d = c
e = c[:]
print("id(c): ", id(c), "\nid(d): ",  id(d), "\nid(e): ", id(e))