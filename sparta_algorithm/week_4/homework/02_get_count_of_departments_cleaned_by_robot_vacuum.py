"""
**문제 설명**
로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.

로봇 청소기가 있는 장소는 N×M 크기의 직사각형으로 나타낼 수 있으며,
1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다.
청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북중 하나이다.
지도의 각 칸은 (r, c)로 나타낼 수 있고, r은 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로 부터 떨어진 칸의 개수이다.

로봇 청소기는 다음과 같이 작동한다.
1. 현재 위치를 청소한다.
2. 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.
    a. 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
    b. 왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.
    c. 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.
    d. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.
로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다.

**입력 조건**
로봇 청소기가 있는 칸의 좌표 (r, c)와 바라보는 방향 d가 주어진다. 이 때 d가 0인 경우에는 북쪽을,
1인 경우에는 동쪽을, 2인 경우에는 남쪽을, 3인 경우에는 서쪽을 바라보고 있는 것이다.

또한 청소하고자 하는 방의 지도를 2차원 배열로 주어진다.
빈 칸은 0, 벽은 1로 주어진다. 지도의 첫 행, 마지막 행, 첫 열, 마지막 열에 있는 모든 칸은 벽이다.

로봇 청소기가 있는 칸의 상태는 항상 빈 칸이라고 했을 때,
로봇 청소기가 청소하는 칸의 개수를 반환하시오.

"""

current_r, current_c, current_d = 7, 4, 0
current_room_map = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],  # 0
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],  # 1
    [1, 0, 0, 0, 1, 1, 1, 1, 0, 1],  # 2
    [1, 0, 0, 1, 1, 0, 0, 0, 0, 1],  # 3
    [1, 0, 1, 1, 0, 0, 0, 0, 0, 1],  # 4
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],  # 5
    [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],  # 6
    [1, 0, 0, 0, 0, 0, 1, 1, 0, 1],  # 7
    [1, 0, 0, 0, 0, 0, 1, 1, 0, 1],  # 8
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],  # 9
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]   # 10
]

# 방향에 맞게 + - 값을 리스트로 정렬해서 인덱스에 둘다 + 해도 가로 세로 값에 지장을 주지 않는다.
dr = [-1, 0, 1, 0]
dc = [0, 1, 0, -1]

# 방향 전환 왼쪽으로(반시계 방향)
def get_d_index_when_rotate_to_left(d):
    return (d + 3) % 4

# 현재 방향에서 뒤로 즉, 방향을 180도 돌리기
def get_d_index_when_go_back(d):
    return (d + 2) % 4


def get_count_of_departments_cleaned_by_robot_vacuum(r, c, d, room_map):
    n = len(room_map)
    m = len(room_map[0])
    room_map[r][c] = 2
    cleaned_room_count = 1
    queue = [[r, c, d]]

    # 탈출 조건으로 큐를 썻기때문에 활용해야 한다.
    # 2.
    while queue:
        r, c, d = queue.pop(0)
        temp_d = d

        # range(4)를 하는 이유는 막혀있거나 청소한 공간은 넘기고 좌표의 값이 0인값을 찾기위해서 최대 4번을 체크한다.
        for i in range(4):
            # 왼쪽 방향으로 방향을 바꾸는 메소드
            temp_d = get_d_index_when_rotate_to_left(temp_d)
            # 템프 값으로 한칸 앞으로 이동하는 가상의 변수를 만듬 가상의 변수를 만드는 이유는 그 공간이 막혀있거나 청소한 공간일 수 있기떄문에 템프 값으로 선언
            new_r, new_c = r + dr[temp_d], c + dc[temp_d]

            # 해설에는 0 <= new_r < n and 0 <= new_c < m 부분이 있는데 이동하는 좌표가 범위를 벗어나지 않는 조건을 넣은것
            # 하지만 문제에는 테두리에 1로 칠해져있기때문에 이 조건은 넣지 않아도 된다.
            if room_map[new_r][new_c] == 0:
                # 새로운 방이기 때문에 청소
                room_map[new_r][new_c] = 2
                # 청소한 방의 횟수 증가
                cleaned_room_count += 1
                # queue 배열에 현재 있는 좌표를 리스트로 넣어준다. 왜냐하면 처음에 꺼낼때 리스트 형식으로 꺼냇기 때문에
                queue.append([new_r, new_c, temp_d])
                # 한칸씩만 이동하기때문에 새로운방을 칠하고 2. 의 조건들을 다시 반복
                break

            # c
            # 모든 방향을 다 봤는데 새로운 방이 안보일때, 방향을 유지한채 한 칸 뒤로간다.
            elif i == 3:
                # 확실할때만 원래 값을 사용하고 시뮬레이션 즉, 한칸을 이동해보는 것들은 템프 값들을 사용한다. (temp = new)
                # 여기에선 그냥 r, c 의 값을 바꾸어도 상관없다. 마지막에 방향 d 를 넣는 이유는 방향이 틀어져있기 때문
                new_r, new_c = r + dr[get_d_index_when_go_back(d)], c + dc[get_d_index_when_go_back(d)]

                # 뒤로 이동하려는데 만약에 뒤가 벽이면 청소한 방 개수를 반환한다.
                if room_map[new_r][new_c] == 1:
                    return cleaned_room_count

                # 뒤가 벽이 아니면 뒤로 한칸 이동한 좌표를 queue값에 넣어준다. // 현재 나의 좌표
                queue.append([new_r, new_c, d])

# 57 가 출력되어야 합니다!
# print(get_count_of_departments_cleaned_by_robot_vacuum(current_r, current_c, current_d, current_room_map))
# current_r, current_c, current_d = 7, 4, 0

#list() 함수는 안에 있는 값을 리스트로 만들어 주는게 아니라 리스트 형식으로 바꿀 수 있으면 리스트로 바꾸어 주는 것을 의미한다.
alpa = {3, 1, 2}

alpa.add(5)
print(type(alpa))
print(alpa)

"""
문제 풀이
행과 열값을 받아서
n, m
cleaned_try_count = 1
room_map[r][c] = 2

temp_d = d

for i in range(4)
temp_d <--  방향을 바꿈
new_r, new_c = r +c

"""






