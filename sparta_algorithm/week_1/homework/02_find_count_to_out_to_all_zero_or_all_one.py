"""
0과 1로만 이루어진 문자열이 주어졌을 때, 이 문자열에 있는 모든 숫자를 전부 같게 만들려고 한다.
할 수 있는 행동은 문자열에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을
0으로, 0을 1로 바꾸는 것을 의미한다.

예를 들어 S=0001100 일 때,

전체를 뒤집으면 1110011이 된다.
4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.
하지만, 처음부터 4번째 문자부터 5번쨰 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에
모두 같은 숫자로 만들 수 있다.

주어진 문자열 모두 0 혹은 모두 1로 같게 만드는 최소 횟수를 반환하시오.

알고리즘의 순서
1. 모든 숫자가 1인경우와 0인경우 두가지의 카운트 값을 저장할 변수를 만들어주고
2. 반복문으로 문자열 만큼 사이클을 돌려준다 이때 2개씩 문자를 비교해야 하기때문에
    range(1, len(string) 으로 돌려준다.
3. 반복의 현재 문자와 바로 직전의 문자가 다른 경우 count 값을 조건에 맞게 +1 해준다
4. 최소의 값을 반환할때 조건은 처음에 오는 문자와 다른 경우 부터 뒤집는 것이 최소 이기때문에
    첫번째가 0이라면 all_zero를 반환 else일 경우 all_one을 반환해준다.

여기서 주의 할 점은 두개의 카운트 값을 대소로 비교할때 필요한 조건
문자열[0] == 0 인경우, all_one 값을 + 1 하고 비교연산을 해야 한다.
이유는 문자열[1]번부터 앞과 뒤를 비교한뒤 카운트 값을 처리했기 때문에
문자열[0]의 값을 뒤집은 카운트가 누락되었기 때문이다.

"""

input = "011110"


def find_count_to_turn_out_to_all_zero_or_all_one(string: str) -> int:
    all_zero = 0  # 모든 값을 0로 뒤집을 경우의 횟수
    all_one = 0  # 모든 값을 1로 뒤집을 경우의 횟수

    for i in range(1, len(string)):

        if string[i] != string[i-1]:  # 현재 문자와 이전 문자가 다른경우 뒤집는 처리
            if string[i] == '0':  # 현재의 문자가 0인지 1인지 체크
                all_one += 1
            else:
                all_zero += 1

    if string[0] == '0':  # 문자열[0]의 값을 기준으로 뒤집은 횟수를 리턴해준다.
        return all_zero
    else:
        return all_one


result = find_count_to_turn_out_to_all_zero_or_all_one(input)
print(result)